// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using Microsoft.CodeAnalysis.Sarif.Driver;

namespace Microsoft.CodeAnalysis.BinaryParsers.ProgramDatabase
{
    public enum SwitchState
    {
        SwitchNotFound = 0,
        SwitchEnabled = 1,
        SwitchDisabled = -1
    }

    public enum OrderOfPrecedence
    {
        FirstWins = 0,
        LastWins = 1
    }

    public struct CommandLineSwitch
    {
        CommandLineSwitch(string name, SwitchState state)
        {
            Name = name;
            State = state;
        }

        public string Name;
        public SwitchState State;
    };

    public struct CompositeSwitchState
    {
        CompositeSwitchState(CommandLineSwitch[] switchArray)
        {
            compositeSwitch = switchArray;
        }
        public CommandLineSwitch[] compositeSwitch;

        SwitchState State()
        {
            if (compositeSwitch.Length >= 1)
            {
                return compositeSwitch[0].State;
            }
            else
            {
                return SwitchState.SwitchNotFound;
            }
        }
    }

    /// <summary>Processes command lines stored by compilers in PDBs.</summary>
    internal struct CompilerCommandLine
    {
        // I can't defend this design where the "once-ness" and the level of the warning
        // are part of the same value; but it's what the native compiler does :(
        //
        // See email from the compiler team attached to twcsec-tfs01 bug# 17770
        //
        // (Causes many WTFs like:
        //     cl.exe /c /W1 /wd4265 /w14265 /wo4265 C4265.cpp
        // emits no warning, but
        //     cl.exe /c /W1 /wd4265 /w14265 C4265.cpp
        // does.)

        private enum WarningState
        {
            Level1 = 1,
            Level2 = 2,
            Level3 = 3,
            Level4 = 4,
            AsError,
            Once,
            Disabled
        }

        static private char[] switchPrefix = new char[] { '-', '/' };

        /// <summary>
        /// The raw, unadulterated command line before processing.
        /// </summary>
        public readonly string Raw;

        /// <summary>
        /// The set of warnings explicitly disabled in this command line. Sorted.
        /// </summary>
        public readonly ImmutableArray<int> WarningsExplicitlyDisabled;

        /// <summary>
        /// The warning level (/W1, /W3, /Wall, etc.) in the range [0, 4] from this command line.
        /// </summary>
        public readonly int WarningLevel;

        /// <summary>
        /// Whether or not this command line treats warnings as errors.
        /// </summary>
        public readonly bool WarningsAsErrors;

        /// <summary>
        /// Initializes a new instance of the <see cref="CompilerCommandLine"/> struct from a raw PDB-supplied command line.
        /// </summary>
        /// <param name="commandLine">The raw command line from the PDB.</param>
        public CompilerCommandLine(string commandLine)
        {
            //
            // https://msdn.microsoft.com/en-us/library/thxezb7y.aspx
            //

            this.Raw = commandLine ?? "";
            this.WarningLevel = 0;
            this.WarningsAsErrors = false;
            var explicitWarnings = new Dictionary<int, WarningState>();
            foreach (string argument in ArgumentSplitter.CommandLineToArgvW(commandLine))
            {
                if (!IsSwitch(argument))
                {
                    continue;
                }

                switch (argument.Length)
                {
                    case 2:
                        // /w Disables all compiler warnings.
                        if (argument[1] == 'w')
                        {
                            this.WarningLevel = 0;
                        }
                        break;
                    case 3:
                        if (argument[1] == 'W')
                        {
                            char wChar = argument[2];
                            if (wChar == 'X')
                            {
                                // Treats all compiler warnings as errors.
                                this.WarningsAsErrors = true;
                            }
                            else if (wChar >= '0' && wChar <= '4')
                            {
                                // Specifies the level of warning to be generated by the compiler.
                                this.WarningLevel = (int)wChar - (int)'0';
                            }
                        }
                        break;
                    case 4:
                        if (argument.EndsWith("WX-"))
                        {
                            // (inverse of) Treats all compiler warnings as errors.
                            this.WarningsAsErrors = false;
                        }
                        break;
                    case 5:
                        if (argument.EndsWith("Wall"))
                        {
                            // Displays all /W4 warnings and any other warnings that are not included in /W4
                            this.WarningLevel = 4;
                        }
                        break;
                    case 7:
                        if (argument[1] != 'w')
                        {
                            break;
                        }

                        WarningState state;
                        char mode = argument[2];
                        if (mode == 'd')
                        {
                            // Disables the compiler warning that is specified
                            state = WarningState.Disabled;
                        }
                        else if (mode == 'e')
                        {
                            // Treats as an error the compiler warning that is specified
                            state = WarningState.AsError;
                        }
                        else if (mode == 'o')
                        {
                            // Reports the error only once for the compiler warning that is specified
                            state = WarningState.Once;
                        }
                        else if (mode >= '1' && mode <= '4')
                        {
                            // Specifies the level for a particular warning.
                            // e.g. /w14996 sets 4996 to level 1
                            state = (WarningState)((int)mode - (int)'1' + (int)WarningState.Level1);
                        }
                        else
                        {
                            break;
                        }

                        int warningNumber;
                        if (!Int32.TryParse(argument.Remove(0, 3), (NumberStyles)0, CultureInfo.InvariantCulture, out warningNumber))
                        {
                            break;
                        }

                        explicitWarnings[warningNumber] = state;
                        break;
                }
            }

            var explicitlyDisabledBuilder = ImmutableArray.CreateBuilder<int>();
            foreach (KeyValuePair<int, WarningState> entry in explicitWarnings)
            {
                bool isEnabled;
                switch (entry.Value)
                {
                    case WarningState.AsError:
                    case WarningState.Once:
                        isEnabled = true;
                        break;
                    case WarningState.Disabled:
                        isEnabled = false;
                        break;
                    case WarningState.Level1:
                        isEnabled = this.WarningLevel >= 1;
                        break;
                    case WarningState.Level2:
                        isEnabled = this.WarningLevel >= 2;
                        break;
                    case WarningState.Level3:
                        isEnabled = this.WarningLevel >= 3;
                        break;
                    case WarningState.Level4:
                        isEnabled = this.WarningLevel >= 4;
                        break;
                    default:
                        isEnabled = true;
                        Debug.Fail("Unexpected WarningState");
                        break;
                }

                if (!isEnabled)
                {
                    explicitlyDisabledBuilder.Add(entry.Key);
                }
            }

            explicitlyDisabledBuilder.Sort();
            this.WarningsExplicitlyDisabled = explicitlyDisabledBuilder.ToImmutable();
        }

        private static bool IsSwitch(string candidate)
        {
            if (candidate.Length < 2)
            {
                return false;
            }

            char c = candidate[0];
            return c == '/' || c == '-';
        }

        // Determine if a switch is set,unset or not present on the command-line
        // Case matters
        public SwitchState GetSwitchState(string switchName, OrderOfPrecedence precedence)
        {
            SwitchState currentState = SwitchState.SwitchNotFound;

            string[] realSwitch = new string[] { switchName };

            currentState = GetSwitchStateFactoringOverrides(realSwitch, currentState, precedence);

            return currentState;
        }

        public SwitchState GetSwitchStateWithAliases(string[] switchNames, SwitchState defaultState, OrderOfPrecedence precedence)
        {
            SwitchState state = SwitchState.SwitchNotFound;

            string[] realSwitches = new string[switchNames.Length];

            for (int index = 0; index < switchNames.Length; index++)
            {
                realSwitches[index] = switchNames[index].TrimStart(switchPrefix);
            }

            foreach (string arg in ArgumentSplitter.CommandLineToArgvW(Raw))
            {
                if (IsSwitch(arg))
                {
                    string realArg = arg.TrimStart(switchPrefix);

                    for (int index = 0; index < realSwitches.Length; index++)
                    {
                        if (realArg.StartsWith(realSwitches[index]))
                        {
                            // partial stem match - now check if this is a full match or a match with a "-" on the end
                            if (realArg.Equals(realSwitches[index]))
                            {
                                state = SwitchState.SwitchEnabled;
                            }
                            else if (realArg[realSwitches[index].Length] == '-')
                            {
                                state = SwitchState.SwitchDisabled;
                            }
                            // Else we have a stem match

                            if (precedence == OrderOfPrecedence.FirstWins)
                                break;
                        }
                    }
                }
            }

            if(state == SwitchState.SwitchNotFound)
            {
                state = defaultState;
            }

            return state;
        }
        // Get the state of the initial switch in the array if it and the subsequent switches override eachother
        public SwitchState GetSwitchStateFactoringOverrides(string[] switchNames, SwitchState defaultStateOfFirst, OrderOfPrecedence precedence)
        {
            SwitchState compositeState = SwitchState.SwitchNotFound;

            if (switchNames.Length > 0)
            {
                // convert string array to CommandLineSwitch objects for search
                CommandLineSwitch[] switchArray = new CommandLineSwitch[switchNames.Length];

                for (int index = 0; index < switchNames.Length; index++)
                {
                    // if present remove the slash or minus
                    switchArray[index].Name = switchNames[index].TrimStart(switchPrefix);
                    switchArray[index].State = SwitchState.SwitchNotFound;
                }

                foreach (string arg in ArgumentSplitter.CommandLineToArgvW(Raw))
                {
                    if (IsSwitch(arg))
                    {
                        string realArg = arg.TrimStart(switchPrefix);

                        for (int index = 0; index < switchArray.Length; index++)
                        {
                            if (realArg.StartsWith(switchArray[index].Name))
                            {
                                // partial stem match - now check if this is a full match or a match with a "-" on the end
                                if (realArg.Equals(switchArray[index].Name))
                                {
                                    switchArray[index].State = SwitchState.SwitchEnabled;

                                    if (index != 0)
                                    {
                                        switchArray[0].State = SwitchState.SwitchDisabled;
                                    }
                                }
                                else if (realArg[switchArray[index].Name.Length] == '-')
                                {
                                    switchArray[index].State = SwitchState.SwitchDisabled;
                                }
                                // Else we have a stem match

                                if (precedence == OrderOfPrecedence.FirstWins)
                                    break;
                            }
                        }
                    }
                }

                if (switchArray[0].State == SwitchState.SwitchNotFound)
                {
                    bool anyOtherSwitchSet = false;

                    for (int index = 1 /*skip the initial switch*/ ; index < switchArray.Length; index++)
                    {
                        if (switchArray[index].State == SwitchState.SwitchEnabled)
                        {
                            anyOtherSwitchSet = true;
                            break;
                        }
                    }

                    if (anyOtherSwitchSet)
                    {
                        compositeState = SwitchState.SwitchDisabled;
                    }
                    else
                    {
                        compositeState = defaultStateOfFirst;
                    }
                }
                else
                {
                    compositeState = switchArray[0].State;
                }
            }

            return compositeState;
        }
    }
}
